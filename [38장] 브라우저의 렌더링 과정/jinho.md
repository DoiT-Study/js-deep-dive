# 38장 브라우저의 렌더링 과정
파싱: 구문 분석<br>
렌더링: HTML, CSS, 자바스크립트로 작성된 문서를 파싱하여 브라우저에 시각적으로 출력하는 것
## 38.1 요청과 응답
* 필요한 리소스(HTML, CSS, 자바스크립트, 이미지, 폰트 등)를 서버에 요청하고 서버로부터 응답받아 렌더링한다.
* 서버에 요청을 전송하기 위해 브라우저는 주소창을 제공
## 38.2 HTTP 1.1과 HTTP 2.0
HTTP : 웹에서 브라우저와 서버가 통신하기 위한 프로토콜(규약)이다.

HTTP1.1
* 커넥션(connection)당 하나의 요청과 응답만 처리 => 리소스 동시 전송 불가능 => 리소스 비레하여 응답 시간도 증가

HTTP2.0
* 다중 요청/응답이 가능하다. => 리소스 동시 전송 가능 => 1.1보다 50% 정도 빠르다. 

## 38.3 HTML 파싱과 DOM 생성
브라우저의 요청에 의해 서버가 응답한 HTML 문서는 문자열로 이루어진 텍스트다.<br>
=>시각적인 픽셀로 렌더링하기 위해 HTML문서를 브라우저가 이해할 수 있는 자료구조로 변환하여 메모리에 저장

`브라우저가 이해할 수 있는 자료구조, HTML 문서를 파싱한 결과물 => DOM`

## CSS 파싱과 CSSOM 생성
* HTML을 파싱하며 DOM을 생성하다가 CSS를 만나면 DOM생성 일시중지
* HTML과 동일한 파싱 과정으로 해석한 뒤 CSSOM을 생성
* CSS파싱을 완료하면 HTML파싱이 중단된 지점부터 HTML을 다시 파싱하기 시작

## 렌더 트리 생성
렌더 트리: 렌더링을 위한 트리 구조의 자료구조다. => 브라우저 화면에 렌더링되는 노드만으로 구성된다. 

완성된 렌더 트리는 각 HTML 요소의 레이아웃(위치와 크기)을 계산하고 페인트하는데 사용

## 38.6 자바스크립트 파싱과 실행
토크나이징: 단순한 문자열인 자바스크립트 소소코드를 어휘 분석하여 토큰(문법적 의미를 갖는 코드의 최소 단위)들로 분해<br>
파싱: 토큰들의 집합을 구문 분석하여 AST(추상적 구문 트리)를 생성<br>
`AST: 토큰에 문법적 의미와 구조를 반영한 트리구조의 자료구조다

=> 파싱의 결과물로서 생성된 AST는 인터프리터가 실행할 수 있는 중간 코드인 바이트코드로 변환되고 인터프리터에 의해 실행된다.

## 38.7 리플로우와 리페인트
DOM API를 통해 자바스크립트 코드에서 DOM이나 CSSOM이 변경되면 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합된다.<br>
=> 변경된 렌더 트리를 기반으로 다시 레이아웃(리플로우)과 페인트과정(리페인트)을 거친다. 

## 38.8 자바스크립트 파싱에 의한 HTML 파싱 중단
자바스크립트 엔진과 렌더링 엔진은 직렬적으로 파싱을 수행<br>
=> 브라우저는 동기적으로 즉, **위에서 아래방향**으로 순차적으로 HTML, CSS, 자바스크립트를 파싱하고 실행<br>
=> script 태그의 위치에 따라 HTML 파싱이 블로키되어 DOM생성이 지연될 수 있다.<br>
=> HTML 의 body요소의 맨 마지막에 자바스크립트를 위치시키는 것이 좋다. 
* DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작하면 에러가 발생할 수 있다.
* 페이지 로딩 시간이 단축된다. 

## 38.9 script 태그의 async/ defer 어트리뷰트
자바스크립트 파싱에 의한 DOM 생성이 중단되는 문제를 근본적으로 해결하기 위해 탄생

async 어트리뷰트
* HTML 파싱과 외부 자바스크립트 파일의 로드가 비동기적으로 동시에 진행된다.
* 자바스크립트의 파싱과 실행은 **자바스크립트 파일의 로드가 완료된 직후** 진행되며, 이때 HTML 파싱이 종료된다. <br>
=> 순서 보장 X

defer 어트리뷰트
*  HTML 파싱과 외부 자바스크립트 파일의 로드가 비동기적으로 동시에 진행된다.
* 자바스크립트의 파싱과 실행은 HTML 파싱이 완료된 직후, 즉 DOM 생성이 완료된 직후 진행된다.  
