# 14. 전역 변수의 문제점

> 전역 변수의 무분별한 사용은 프로그래밍 성능 저하와 전역 변수 변형 가능 위험성을 담고있기에 최대한 사용을 하는 것을 지양해야한다.

## 14.1 변수의 생명주기

> 변수는 자신이 선언된 위치에서 생성되고 소멸한다.

### 지역 변수의 생명 주기

변수는 선언에 의해 생성되고 할당을 통해 값을 갖는다. 그리고 언젠가 소멸한다. 지역 변수의 경우에는 어떨까? 함께 살펴보자.

```js
function foo() {
  var x = `local`;
  console.log(x); // local
  return x;
}

foo();
console.log(x);
```

    console.log(x);
                ^
    ReferenceError: x is not defined

위의 코드는 foo() 함수 선언과 foo() 함수 실행, foo()의 지역 변수인 x를 foo() 함수가 종료 된 후 x를 console.log()로 출력하려 하는 것이다. 그러나 실행이 되지 않는다. 왜 그럴까?

함수 내부의 변수는 함수 호출과 동시에 선언되고 함수가 종료하면 소멸하기 때문이다.
그렇기에 함수가 종료된 이후 x의 값을 불러오려고 해도 소멸되었으니 못 불러오고 오류가 생긴다.

> 즉 지역 변수의 생명 주기는 함수의 생명주기와 일치한다.

그러나 함수 몸체에서 생성되었는데도 불구하고 함수의 생명 주기보다 오래 생존하는 경우도 있는데 함수 내에서 외부 참조를 받는 변수가 있다면 그 변수는 함수 종료 이후에도 해제되지 않고 생존하게 된다.

### 전역 변수의 생명 주기

> 전역코드는 함수 호출과 같이 전역 코드를 실행하는 특별한 진입점이 없고 코드가 로드되자마자 곹바로 해석되고 실행된다. 그리고 마지막 몬이 실행되어 더 이상 실행할 문이 없을때 종료한다.

## 14.2 전역 변수의 문제점

### 암묵적 결합

전역 선언은 어디서든 참조하고 할당 할 수 있는 변수를 사용하겠다는 것을 암시한다. 이는 코드의 규모가 커질 수록 가독성을 해치고 의도치 않게 변경될 위험을 만들 여지도 제공한다.

### 긴 생명 주기

전역 변수는 생명주기가 길다. 따라서 메모리 리소스 소비 기간도 길다. 이 기간 동안 전역 변수의 상태를 변경 할 수 있는 시간도 길고 기회도 많아지게 된다.

### 스코프 체인 상에서 종점에 존재

전역 변수는 스코프 체인 상에서 종점에 존재하는데 이는 가장 마지막에 검색되는 변수라는 것을 의미한다. 즉, 전역 변수의 검색속도가 가장 느리기에 성능저하를 가져올 수 있다.

### 네임스페이스 오염

자바스크립트의 문제점 중 하나는 파일일 분리되어 있다고 해도 하나의 전역 스코프를 공유한다는 것이다. 따라서 다른 파일 내에 동일한 이름으로 명명된 전역변수나 전역 함수가 같은 스코프 내에서 존재할 경우 예상치 못한 결과를 가져올 수 있다.

## 14.3 전역 변수 사용을 억제하는 방법

> 전역변수를 사용해야할 확실한 이유를 찾지 못한다면 지역변수를 사용하자.

### 즉시 실행 함수

모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행함수의 지역 변수가 된다.

```js
(function () {
  var foo = 10; // 즉시실행 함수의 전역 변수
  // ...
})();

console.log(foo); // ReferenceError: foo is not defined
```

### 네임스페이스 객체

전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수 처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방식이다.

또 전역 네임 스페이스에 또다른 네임 스페이스 객체를 추가해서 네임스페이스를 계층적으로 구성 할 수도 있다.

```js
var MYAPP = {}; // 전역 네임 스페이스 객체

MYAPP.name = `lee`;
MYAPP.person = {
  address: `Seoul`,
};

console.log(MYAPP.name); // lee
console.log(MYAPP.person.address); // Seoul
```

### 모듈 패턴

class를 모방한 것으로 전역변수의 억제는 물론 캡슐화까지 구현할 수 있다.

```js
var Counter = (function () {
  // private
  var num = 0;

  //public
  return {
    increase() {
      return ++num;
    },
    decrease() {
      return --num;
    },
  };
})();

console.log(Counter.num); // undefined
console.log(Counter.increase()); // 1
console.log(Counter.increase()); // 2
console.log(Counter.decrease()); // 1
console.log(Counter.decrease()); // 0
```

```
1
2
1
0
```

### ES6 모듈

ES6를 사용하면 더 이상 전역 변수를 사용할 수 없다. ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공한다. 따라서 모듈 내에서 var키워드로 변수를 선언하여도 더이상 이는 전역 변수가 아니며 window 객체의 프로퍼티도 아니다.

```js
<script type = "module" src="lib.mjs"></script>
<script type = "module" src="app.mjs"></script>
```
