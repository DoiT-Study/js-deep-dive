결론부터 박고 시작하겠습니다.
콜백 패턴은 콜백 헬로 인해 가독성이 나쁘고, 그 수가 많아질수록 한번에 처리하는 데도 한계가 있다
이 콜백 패턴을 보완하기 위해 프로미스라는 또다른 비동기 처리를 위한 패턴이 등장하였다.

## 45.1 비동기 처리를 위한 콜백 패턴의 단점

콜백 함수가 뭔지부터..<br>
`
A callback function is a function passed into another function as an argument, which is then invoked inside the outer function to complete some kind of routine or action.`

비동기 함수란

- 함수 내부에 비동기로 동작하는 코드를 포함한 함수
- 호출 시 내부의 비동기 코드가 완료되지 않아도, 기다리지 않고 종료해버린다
- 비동기 코드는 비동기 함수가 종료된 이후 완료된다

이러한 특성 때문에, 비동기로 동작하는 코드에서의 처리 결과는 볼 수 없다

외부로 리턴하는 것도, 상위 스코프의 변수에 할당하는 것도 효과 없음!!

결론 : 비동기 함수의 처리 결과에 대한 처리는 비동기 함수 내부에서 끝내버려야 한다. 그러기 위해 콜백 함수를 전달하는 것이 일반적.

하지만 그러다 보면 콜백 함수가 끝없이 중접되어 콜백 헬이 발생한다.

## 45.2 프로미스의 생성

이러한 콜백함수의 문제점을 극복하기 위해 나온 패턴이 Promise 다.

프로미스는 비동기 처리가 어떻게 진행되고 있는지의 대한 상태 정보를 제공한다
pending: 비동기 처리 아직 수행 전
fulfilled: 비동기 처리 성공
rejected: 비동기 처리 수행 실패

## 45.3 후속 처리 메서드

콜백은 후속 처리를 하는 과정에서 콜백 헬이 생기는 단점이 있었다. 이번에는 프로미스의 후속 처리 메서드에 대해 알아보자

`모든 후속처리 메서드는 프로미스를 반환한다.
모든 후속처리 메서드는 비동기로 동작한다.`

**then**

fulfilled,rejected 시 사용.

**catch**

rejected 시 사용. 위에 rejected 시 사용하는 then과 동일하게 동작한다.

그렇다면 무엇을 쓰는 것이 더 좋나요?

=> catch 메서드를 사용하는 것이 더 일반적이고 권장됩니다. catch 메서드를 사용하면 코드가 더 명확해지고, 에러 처리에 관련된 부분이 명시적으로 표현됩니다.

**finally**

fulfilled,rejected 와 상관없이 무조건 한 번 호출된다
이는 모든 걸 다 떠나서 공통적으로 수행해야하는 내용이 있을 때 유용하다

## 45.4 프로미스의 에러 처리

```js
promiseGet("httpi://jsdeepdive/1")
  .then((res) => console.log("success!!"))
  .catch((err) => console.error(err));
```
