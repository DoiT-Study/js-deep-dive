## 23.5 렉시컬 환경

렉시컬 환경은 하나의 자료구조.

식별자, 식별자에 바인딩된 값, 상위 스코프에 대한 참조를 기록

객체 형태의 스코프를 생성한다 이때 `키는 식별자`이다.

실행 컨텍스트는 LexicalEnviroment과 variableEnviroment 컴포넌트로 구성된다.

이 컴포넌트들이 생성 초기에는 하나의 동일한 렉시컬 환경을 참조함.
나중에 참조가 달라기지도 하지만 이 책에서는 컴포넌트를 구별짓지 않고(LexicalEnviroment과 variableEnviroment 컴포넌트) 렉시컬 환경으로 통일한다.

> 실행 컨텍스트가 렉시컬 환경을 참조한다~ 이렇게 생각하면 된다

렉시컬 환경은 이렇게 두 개의 컴포넌트로 구성된다.

- 환경 레코드
- 외부 렉시컬 환경에 대한 참조

환경 레코드 : 식별자 등록. 등록된 식별자에 바인딩된 값 관리
외부 렉시컬 환경에 대한 참조 : 상위 스코프. 해당 실행 컨텍스트를 생성한 소스코드를 포함하는 코드의 렉시컬 환경.

### 실행 컨텍스트의 생성과 식별자 검색 과정

전역 코드가 평가되기 전, **전역 객체**가 생성된다. <br>
전역 객체는 Object.prototype 상속받음. 즉, 프로토타입 체인의 일원!

#### 전역 코드 평가의 순서

1. 전역 실행 컨텍스트 생성
2. 전역 렉시컬 환경 생성
   1. 전역 환경 레코드 생성
      1. 객체 환경 레코드 생성
      2. 선억적 환경 레코드 생성
   2. this 바인딩
   3. 외부 렉시컬 환경에 대한 참조 결정

하나씩 살펴보자!!

#### 1. 전역 실행 컨텍스트 생성

생성 후 실행 컨텍스트 스택에 푸시한다

#### 2. 전역 렉시컬 환경 생성

생성 후 전역 실행 컨텍스트에 바인딩

렉시컬 환경은 2개의 컴포넌트, 환경 레코드와 외부 렉시컬 환경에 대한 참조로 구성된다.

`ES6 이전:`
모든 전역 변수가 전역 객체의 프로퍼티가 됐다.
전역 객체가 전역 환경 레코드 역할을 했다.

`ES6 이후:`
let,const로 선언한 전역 변수는 전역 객체의 프로퍼티가 되지 않는다!!
개념적인 블록 내에 존재하게 된다.
개념적인 블록이 뭔가요???
-> 그건 뒤에서 설명...

let const 로 선언한 전역 변수와 var로 선언한 전역 변수를 구분짓어 관리하기 위해
전역 환경 레코드는 `객체 환경 레코드`와 `선언적 환경 레코드`로 구성되어 있다.

**객체 환경 레코드가 관리하는 것**

- var 키워드로 선언한 전역 변수, 전역 함수
- 빌트인 전역 프로터이와 빌트인 전역 함수
- 표준 빌트인 객체

**선언적 환경 레코드가 관리하는 것**

- let const 키워드로 선언한 전역 변수

이 둘이 협력하여 전역 스코프와 전역 객체를 관리한다.

## 객체 환경 레코드 생성

객체 환경 레코드는 BindingObject(일종의 전역 객체다) 와 연결된다.
그리고 이것을 통해 전역 변수는 전역 객체의 프로퍼티
전역 함수는 전역 객체의 메서드가 된다

이 때 등록된 식별자를(환경 레코드에 등록되어있겠죠??) 전역 환경 레코드의 객체 환경 레코드에서 검색하면 **전역 객체의 프로퍼티를 검색하여 변환한다**
그래서 전역 객체를 가리키는 식별자 없이 객체의 프로퍼티를 참조할 수 있게 되는 것이다!!

```js
// 전역 스코프에서 변수 선언
var globalVariable = 42;

// 전역 스코프에서 함수 정의
function exampleFunction() {}
```

var 키워드로 선언한 변수는 선언 단계와 초기화 단계가 동시에 진행된다
(선언함과 동시에 undefined로 초기화)

-> 전역 코드 평가 시점에 BindingObject를 통해서 전역 객체에 등록하고(키는 변수 식별자) 암묵적으로 undefined 할당

함수 선언문으로 정의한 함수는
BindingObject를 통해 전역 객체에 등록하고 생성된 함수 객체를 `즉시 할당한다`.
함수 선언문 이전에 호출할 수 있음

### 선언적 환경 레코드 생성

선언적 환경 레코드에는 let,const로 선언한 변수 관리.
아까 말했던 개념적 블록이 이 선언적 환경 레코드다

이 변수들은 전역 객체의 프로퍼티가 되지 않는다. window.y처럼 전역 객체의 프로퍼티로서 참조 못함.

여기서 일시적 사각지대 (Temporal Dead Zone, TDZ) 가 발생할 수 있다

```js
console.log(apple);
let apple = "apple";
```

```js
{
  console.log(apple);
  let apple = "apple";
}
```

뭐라고 뜰까요??

TDZ(Temporal Dead Zone)에 대한 경고로서, 변수가 선언되었지만 초기화되기 전에 접근하려고 하는 시점을 가리킨다.

런타임에 컨트롤이 변수선언문에 도달하기 전까지 참조를 하지 못한다. 이를 일시적 사각지대에 빠진다고 표현한다

외부 렉시컬 환경에 대한 참조는 전역 코드를 평가 중일 때는 null이다.
이는 전역 렉시컬 환경이 스코프 체인의 종점에 존재함을 의미한다~!

### 식별자 결정

변수 할당문 또는 함수 호출문을 실행하려면 먼저 선언된 식별자인지 확인해야한다.
또 식별자는 스코프가 다르면 같은 이름이 가질 수 있다.
따라서 어느 스코프를 참조할 지도 결정해야한다

이 과정들을 `식별자 결정`이라고 한다

일단 실행 중인 실행 컨텍스트에서 검색 시작
-> 만약 없으면?

외부 렉시컬 환경에 대한 참조를 보고 상위 스코프로 이동

-> 찾을 때까지 반복.

만약 전역 렉시컬 환경(스코프 체인의 종점)까지 갔는데 없다 -> ReferenceError -> 식별자 결정에 실패한것

### 실행 컨텍스트와 블록 레벨 스코프

var 는 함수레벨 스코프를 따름<br>
let const는 블록 레벨 스코프를 따름

for문 안에서 let으로 선언된 변수는 코드 블록이 반복하여 실행할때마다 새로운 렉시컬 환경을 생성한다.
-> 이에 대해선 클로저에서 알아본다
