# 12.1 함수

## 함수
- 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것
- 함수 이름, 매개변수, 인수, 반환값 등을 기본 구성요소로 하여 이루어져 있음 (상황에 따라 생략 가능)

```javascript
function add(x, y){
    return x+y;
}

add(2, 5);
```
- add : 함수 이름
- (x, y) : 매개변수
- x+y : 반환값
- (2, 5) : 인수


## 12.2 함수를 사용하는 이유
- 코드의 유지보수성
- 코드의 신뢰성 (실수를 줄인다)
- 코드의 가독성 => 코드는 동작하는 것만이 존재 목적이 아니고 개발자를 위한 문서이기도 하다


## 12.3 함수 리터럴
- 구성요소 : 함수 이름, 매개변수 목록, 함수 몸체 (함수 이름 생략 가능)

```javascript
var f = function add(x, y) {
    return x+y;
};
```
함수 리터럴도 평가되어 값을 생성하며 이 값은 객체다.
즉, 함수는 **객체**다


## 12.4 함수 정의
함수를 호출하기 이전에 인수를 전달바다을 매개변수와 실행할 문들, 반환할 값을 지정하는 것

- 함수 정의 방식 : 함수 선언문, 함수 표현식, function 생성자 함수, 화살표 함수

<br>

### 12.4.1 함수 선언문
- 함수 리터럴과 동일한 구조를 가지고 있지만, 함수 이름을 생략할 수 없다는 차이가 있다.

```javascript
function add (x, y) {
    return x+y;
};
```

<br>

### 14.4.2 함수 표현식
- 함수 리터럴로 생성한 함수 객체를 변수에 할당하는 함수 정의 방식
- 함수 이름 생략 가능

```javascript
var add = function foo (x, y) {
    return x+y;
};

```
함수 호출할 때에는 함수 이름(foo)가 아닌 함수 객체를 가리키는 식별자(add)를 사용해야 한다.

<br>

### 14.4.3 함수 생성 시점과 함수 호이스팅
- 함수 호이스팅 : 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징
<br>

? 함수 생성 시점 (함수 선언문 vs 함수 표현식)
<br>
함수 선언문으로 함수를 정의하면, 런타임 이전에 함수 객체가 먼저 생성된다. 이후 자바스크립트 엔진이 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하여 함수 객체를 할당한다. (함수 호이스팅)
<br>
함수 표현식으로 함수를 정의하면, 런타임 이전에 undefined 로 초기화 된 이후 런타임에 함수 리터럴이 함수 객체가 된다. (변수 호이스팅)

<br>

### 14.4.4 function 생성자 함수
- Function 생성자 함수와 new 연산자를 호출하여 함수를 선언하는 방식
- 사용을 지양한다

```javascript
var add = new Function('x', 'y', 'return x+y');
```

### 14.4.5 화살표 함수
- 화살표를 사용해 함수를 선언하는 방식
- 기존 함수와 this 바인딩 방식이 다르고 prototype 프로퍼티가 없으며 arguments 객체를 생성하지 않는다는 특징이 있음

```javascript
const add = (x, y) => x+y;
```

<br>

## 12.5 함수 호출


### 12.5.1 매개변수와 인수
- 인수가 할당되지 않은 매개변수의 값은 undefined다.
- 매개변수보다 인수가 더 많은 경우 초과된 인수는 무시된다.

<br>

### 12.5.2 인수 확인

<br>

### 12.5.3 매개변수의 최대 개수
- 이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만드는 것이 좋다. 따라서 매개변수는 최대 3개 이상을 넘기지 않는 것을 권장한다. 그 이상의 매개변수가 필요하다면 하나의 매개변수를 선언하고 객체를 인수로 전달하는 것이 유리하다.

<br>

### 12.5.4 반환문
- 함수는 return 키워드와 표현식(반환값)으로 이뤄진 반환문을 이용해 실행 결과를 함수 외부로 반환 가능

- 반환문의 역할

    1. 함수의 실행을 중단하고 함수 몸체를 빠져나간다.
    2. return 키워드 뒤에 오는 표현식을 평가해 반환한다.

<br>

## 12.6 참고에 의한 전달과 외부 상태의 변경 
예제)

```javascript
function changeVal(primitive, obj) {
    primitive += 100;
    obj.name = 'Kim';
}

var num = 100;
var person = {name: 'Lee'};

console.log(num); //100
console.log(person); //Lee
```
원시 타입 인수를 전달받은 매개변수 primitive의 경우, 값 자체가 복사되어 매개변수에 전달되기 때문에 함수 몸체에서 값을 변경해도 원본이 훼손되지 않는다.
<br>
객체 타입 인수를 전달받은 매개변수 obj의 경우, 참조 값이 복사되어 매개변수에 전달되기 때문에 함수 몸체에서 참조 값을 통해 객체를 변경할 경우 원본이 훼손된다.


<br>

## 12.7 다양한 함수의 형태

<br>

### 12.7.1 즉시 실행 함수
- 한 번만 호출되며 다시 호출할 수 없다.
- 일반 함수처럼 값을 반환할 수 있다.

```javascript
(function () {
    var a = 3;
    var b = 5;
    return a*b;
}());
```

<br>

### 12.7.2 재귀 함수
- 재귀 호출 : 함수가 자기 자신을 호출하는 것
- 재귀 함수 : 재귀 호출을 수행하는 함수
- 재귀 함수 내에는 재귀 호출을 멈출 수 있는 탈출 조건을 만들어야 한다. 탈줄 조건이 없을 경우 스택 오버플로 에러가 발생한다.

<br>

### 12.7.3 중첩 함수
- 중첩 함수(내부 함수) : 함수 내부에 정의된 함수 / 외부 함수를 돕는 역할을 한다
- 외부 함수 : 중첩 함수를 포함하는 함수

<br>

### 12.7.4 콜백 함수
- 콜백 함수 : 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수
- 고차 함수 : 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수
- 콜백 함수는 고차 함수에 의해 호출되며 고차함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있다.

```javascript
function repeat(n, f) {
    f(i);
}

var logAll = function (i) {
    console.log(i);
};

repeat(5, logAll);
```
- 콜백 함수인 logAll은 고차 함수 repeat에 의해 호출된다.


<br>

### 12.7.5 순수 함수와 비순수 함수
- 순수 함수 : 외부 상태에 의존하지도 않고 변경하지도 않는 부수 효과가 없는 함수
- 비순수 함수 : 외부 상태에 의존하거나 외부 상태를 변경하는 부수 효과가 있는 함수
<br>

순수 함수 예제)
```javascript
var count = 0;

function increase(n) {
    return ++n;
}
```
순수 함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환한다.

<br>

비순수 함수 예제)
```javascript
var count = 0;

function increase() {
    return ++count;
}
```
비순수 함수는 함수의 외부 상태를 변경하는 부수 효과가 있다.
