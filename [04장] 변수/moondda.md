## 4.1 변수란 무엇인가? 왜 필요한가?

어플리케이션의 핵심: 데이터를 입력받아 처리하고 그 결과를 출력하는 것

사람: 계산과 기억을 두뇌에서 한다
컴퓨터: 연산은 CPU 사용, 데이터 기억은 메모리 사용. 모든 데이터 2진수로 처리

### 메모리
- 메모리 셀의 집합체
- 메모리 셀 하나의 크기는 1byte
- 각 셀은 고유의 메모리 주소를 갖는다(0x000000~0xFFFFFFF)
- 1byte 단위로 데이터를 저장하거나 읽어들인다

### 변수 

하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
식별을 위해 붙인 것이므로 값의 의미를 파악할 수 있게 지어야 한다

**코드는 컴퓨에게 내리는 명령임과 동시에 개발자를 위한 문서이기도 하다. 의도를 나타내는 명확한 네이밍은 협업과 품질 향상에 도움을 준다**

여러개의 값을 그룹화해서 하나의 값처럼 사용할 수 있다.

``` javascript
var users = [
    {id: 1, name: "Lee", age: 8},
    {id: 2, name: "Park", age: 10}
]

console.log(users[0].age);
```

변수에 값을 저장 -> 할당
변수에 저장된 값을 읽어 들임 -> 참조

## 4.2 식별자

어떤 값을 구별해서 식별할 수 있는 고유한 이름 ex) 변수, 함수, 클래스 등의 이름

- 식별자는 값이 아니라 메모리 주소를 기억하고 있다
- 식별자는 값이 저장되어 있는 메모리 주소와 매핑 관계를 맺으며, 이 매핑 정보 또한 메모리에 저장된다
- 식별자는 선언에 의해 자바스크립트 엔진에 식별자의 존재를 알린다


## 4.3 변수 선언

var, let, const 키워드를 사용하여 선언한다

변수를 선언: 변수 이름 등록 -> 값을 저장할 메모리 공간 확보 -> 자바스크립트 엔진에 의해 메모리 공간에 undefined라는 값이 할당됨(초기화)

### 자바스크립트 엔진의 변수 선언
- 선언 단계 : 변수의 존재를 알림
- 초기화 단계 : 메모리 공간 확보 및 undefined 할당
  
초기화를 거치지 않으면 이전에 남아 있는 다른 값을 참조하여 쓰레기값(garbage value)이 나올 수 있다
하지만, var은 초기화를 암묵적으로 수행하므로 그러한 위험이 없다

만약 선언하지 않고, 값을 참조하려고 한다면? -> `ReferenceError`
: 값을 참조하려했지만 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 


## 4.4 변수 선언의 실행 시점과 변수 호이스팅

### 변수 호이스팅
변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징

자바스크립트 코드는 인터프리터에 의해 한 줄씩 순차적으로 실행된다
하지만 변수 선언은 런타임(소스코드가 한 줄씩 순차적으로 실행되는 시점) 이전, 소스코드의 평가 과정에서 실행된다

``` javascript
console.log(data); //undefined
//ReferenceError가 발생하지 않는다
var data;
```

## 4.5 값의 할당

자바스크립트는 변수 선언과 값의 할당을 **각각** 실행한다
단축하여 표현되어 있어도 나누어서 실행한다

``` javascript
var age = 23;
```
이 코드도 <br/>

``` javascript
var age;
age = 23;
```
이렇게 작성한 것처럼 동작하는 것<br/><br/>
아래 코드가 어떻게 동작하는지 알아보자
``` javascript
console.log(age);
var age = 23;
console.log(age);
```

먼저 age가 선언되고, 인터프리터가 한 줄씩 실행한다. 처음 console.log(age); 에는 undefined 출력. 그 후로는 23이라는 값이 새롭게 할당되므로 두번째 console.log(age); 에는 23 출력.

여기서 undefined가 저장되어 있는 메모리 공간을 지우고 새롭게 할당 값을 저장하는 것 (x) <br/>
새로운 메모리 공간을 확보하고 그곳에 할당값 저장 (o)

의문점: 
식별자는 메모리 주소와 매핑 관계를 맺는다 했는데, 그 매핑 관계가 재정의 되는건지. 또 그 매핑 정보가 메모리에 저장된다고 했는데 그 값을 재할당할 때도, 새로운 메모리 공간을 확보해서 저장하는지. 

나중에는 undefined로 초기화된 메모리 공간들이 많을텐데 그것에 대한 문제점을 없는지 //4.6에서 해결

## 4.6 값의 재할당

메모리공간이 어떤 식별자와도 연결되어 있지 않으면 가비지 콜렉터에 의해 메모리에서 자동 해제된다.
다만 그 시기는 예측할 수 없다 
memory leak 방지

## 4.7 식별자 네이밍 규칙

- 특수문자를 제외한 문자, 숫자, _, $, 포함 가능
- 숫자로 시작할 순 없다
- 예약어는 사용할 수 없다
- 대소문자는 구별한다

### naming convention
식별자를 만들 때 가동성 좋게 한 눈에 구분하기 위해 규정한 명명 규칙

camelCase //변수 함수 
snake_case
PascalCase // 생성자 함수, 클래스 이름
typeHungarianCase

ECMAScript 사양에 정의되어 있는 객체,함수들은 카멜케이스와 파스칼케이스를 따른다. 내가 개발할 때 보통 스네이크를 자주 쓰는데 카멜을 써보는 것도 좋을 것 같다.