# 25. 클래스

## 25.7 프로퍼티

### 인스턴스 프로퍼티

> 인스턴스 프로퍼티 Constructor에서 정의한 프로퍼티.

인스턴스란? : 비슷한 성질을 가진 여러개의 객체를 만들기 위해, 일종의 설계도라고 할 수 있는 생성자 함수(Constructor)를 만들어 찍어내듯 사용하는데 이렇게 생성된 객체를 인스턴스라 부를 수 있다.

성질 :
public의 성질을 가지고 있다.

### 접근자 프로퍼티

> 접근자 프로퍼티(accessor property)? 값이 없다. 다른 객체의 데이터 프로퍼티를 읽거나 쓸 때 호출하는 함수를 값 대신에 지정할 수 있는 프로퍼티이다. 접근자 프로퍼티의 본질은 함수인데, 이 함수는 값을 획득(get)하고 설정(set)하는 역할을 담당한다. 그런데 외부코드에서는 함수가 아닌 일반적 프로퍼티처럼 보인다.

코드를 보면 getter와 setter로 정의된 함수들이 함수처럼 사용되는 것이 아닌 인스턴스 프로퍼티 처럼 사용되는 것을 볼 수 있을 것이다.

클래스의 메서드는 프로토 타입 메서드가 된다. 따라서 접근자 프로퍼티 또한 인스턴스 프로퍼티가 아닌 프로토타입의 프로퍼티가 된다.

### 클래스 필드 정의 제안

> 현재 js는 java나 다른 객체 지향 언어처럼 클래스 필드를 Constructor만이 아닌 클래스 몸체에서도 선언할 수 있게 바꾸는 과정에 있다. 현재 Node.js 최신 버전에서는 사용가능하다.

#### 클래스 필드?

    클래스 필드는 클래스 기반 객체지향 언어에서 클래스가 생성할 인스턴스의 프로퍼티를 가리키는 내용이다.

```js
class Person {
  name = "Haeonjae";
}
```

#### 아직까지는?

    1. 클래스 몸체에서 클래스 필드를 정의하는 경우, this를 사용하면 안 됨
    2. 클래스 필드 참조시 this를 반드시 사용
    3. 외부 값을 사용하여 클래스 필드를 초기화하기 위해서는 기존의 인스턴스 프로퍼티 선언 방식대로 constructor 안에 초기화해야 함
    4. 클래스 필드에 함수 할당 시, 인스턴스 메서드가 됨

### private 필드 정의 제안

> 현재 js는 또한 java나 다른 객체 지향 언어처럼 private 필드를 정의할 수 있는 새로운 표준사항을 적용할 수 있게 바꿔가고 있다.현재 Node.js 최신 버전에서는 사용가능하다.

#### 캡슐화?

     캡슐화는 객체지향 패러다임 중 하나로, 중요한 데이터를 보존하고 보호하는 것이다. 일반적으로 연관 있는 변수와 함수를 클래스로 묶는 작업을 말한다. 반면, 은닉화는 객체에서 속성을 직접 접근하지 못하게 숨기는 것이다.

```js
class Person {
  #name = "Haeonjae";
}
```

### static 필드의 정의 제안

> 기존 js는 정적 메서드 정의는 가능하나, 정적 필드를 정의하는 것은 불가능 하다. 그러나 꾸준히 제안되어 왔고 현재 Node.js 최신 버전에서는 사용가능하다.

```js
class myMath {
  static PI = 22 / 7;

  static #num = 10;

  static increment() {
    return ++myMath.#num;
  }
}
```

## 25.8 상속에 의한 클래스 확장

### 클래스 상속과 생성자 함수 상속

> 상속에 의한 클래스 확장: 기존 클래스를 상속받아 새로운 클래스를 확장하여 정의하는 것. 클래스를 확장하는 문법인 extends가 제공된다. 생성자 함수는 제공되지 않는다.

### extends 키워드

> 상속을 통해 클래스를 확장하려면 extends 키워드를 사용하여 상속받을 클래스를 정의한다.

                        수퍼 클래스, 베이스 클래스, 부모 클래스

                                        상속

                        서브 클래스, 파생 클래스,   자식 클래스

### 동적 상속

> extends 키워드는 함수또한 상속받아 클래스를 확장 할 수도 있다.

가능한 함수 : [[Construct]] 내부 메서드를 가지는 함수 객체로 평가 될 수 있는 모든 표현식.

### 서브클래스의 constructor

```
constructor(...args) { super(...args); }
```

> 서브클래스의 costructor를 정의하지 않을 시 constructor에는 암묵적으로 수퍼 클래스의 constructor를 호출하여 인스턴스를 생성한다.

### super 키워드

#### super 키워드의 기능

1. super를 호출할 시 수퍼 클래스의 constuctor를 호출한다.
2. 현재 클래스의 인스턴스를 참조 할 수 있는 this와 비슷하게 super를 참조하면 수퍼클래스의 메서드를 참조할 수 있다.

#### 주의점.

1. 서브클래스에서 constructor를 생략하지 않는 경우 서브 클래스의 constuctor에서는 반드시 super를 호출하여 수퍼클래스의 constructor를 호출해야 한다.
2. 서브클래스의 constuctor에서 super를 호출하기 전까지는 this를 참조할 수 없다.
3. super는 반드시 서브클래스의 constuctor에서만 호출한다.

#### super 참조

메서드 내에서 super를 참조하면 수퍼클래스의 메서드를 호출

super를 이용한 참조를 구현한 코드를 보면 super.sayHi를 \_\_super.sayHi.call(this) 바꾼것을 볼 수 있음. 이유는 super는 자신을 참조하고 있는 메서드 의 프로토타입인 Base.prototype를 가리키는데 이에따라 super.sayHi는 Base.prototype.sayHi가 되고 이 함수에서의 this는 Base.prototype니 인스턴스에 접근하여 출력해야하는 함수는 잘못된 참조를 하게 되는 것이다. 그렇기에 call을 사용하여 Derived가 생성한 인스턴스를 가리키는 this를 전달하는 것이다.

super 참조가 동작하기 위해서는?

1. super를 참조하고 있는 메서드가 바인딩되어 있는 객체의 프로토타입을 찾을 수 있어야 함
2. 내부 슬롯 [[Homobject]]가 존재해야 함

클래스에서만 super를 사용할 수 있는 것은 아니지만 ES 6 메서드 축약 표현으로 정의된 함수만 가능하다.

### 상속 클래스의 인스턴스 생성 과정

1. 서브클래스의 super 호출

자바스크립트 엔진은 동작시 수퍼클래스와 서브클래스를 구분하기 위해 내부슬롯 [[ConstructorKind]]을 가진다.

다른 클래스를 상속 받지 않는 클래스는 'base'로 [[ConstructorKind]]값이 설정된다.

다른 클래스를 상속 받는 클래스는 'derived'로 [[ConstructorKind]]값이 설정된다.

이를 통해 수퍼클래스와 서브클래스 동작을 구분한다.

서브클래스는 직접 인스턴스를 생성하지 않고 수퍼클래스에게 인스턴스 생성을 위임한다. 이것이 반드시 서브클래스의 constructor에서 super를 호출해야 하는 이유이다.

2. 수퍼클래스의 인스턴스 생성과 this 바인딩

  수퍼클래스의 constructor 내부가 실행되기 전에 빈 객체를 생성한다.

  인스턴스는 수퍼클래스가 생성한 것이나, new 연산자와 함께 호출된 클래스가 서브클래스이니 new 연산자와 함깨 호출된 함수를 가리키는 new.target은 서브클래스를 가리킨다.

  즉, 인스턴스는 new.target이 가리키는 서브클래스가 생성한 것으로 처리 됨

3. 수퍼클래스의 인스턴스 초기화

   수퍼클래스의 constructor가 실행되어 this에 바인딩된 인스턴스 초기화한다.

4. 서브클래스 constructor로의 복귀와 this 바인딩

  super 호출 종료 후 제어 흐름이 서브클래스의 constructor로 돌아온다.
   이후 suepr가 반환한 인스턴스가 this에 바인딩된다.

5. 서브클래스의 인스턴스 초기화

  서브클래스의 constructor 내부에 super이후 기술 된대로 인스턴스 초기화가 실행된다.

6. 인스턴스 반환

  모든 처리가 끝나면 인스턴스가 바인딩된 this가 암묵적으로 반환된다.

### 표준 빌트인 생성자 함수 확장

> extends의 클래스 뿐만 아니라 [[Construct]] 내부 메서드를 갖는 함수 객체로 평가 될 수 있는 모든 표현식을 클래스 확장에 사용할 수 있는 점을 이용한 확장

```js
class MyArray extends Array {
  uniq() {
    return this.filter((v, i, self) => self.ondexOf(v) === i);
  }

  average() {
    return this.reduce((pre, cur) => pre + cur, 0) / this.length;
  }
}

const myArray = new MyArray(1, 1, 2, 3);

console.log(myArray);

console.log(myArray.uniq());
console.log(myArray.average());
```

```
MyArray(4) [ 1, 1, 2, 3 ]
MyArray(3) [ 1, 2, 3 ]
1.75
```

map, filter라는 함수는 Array.prototype 메서드이다. 이 둘 메서드는 새로운 배열을 반환하는 메서드인데 출력을 보면 MyArray 클래스의 인스턴스를 반환하는 것을 볼 수 있다. 이를통해 MyArray 클래스의 메서드가 Array의 메서드 성공적으로 호출했음을 알 수 있다.
