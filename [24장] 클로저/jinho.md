* 함수형 프로그래밍 언어에서 사용되는 중요한 특성이다.
* 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다. 
## 24.1 렉시컬 스코프
렉시컬 스코프: 함수를 어디에 **정의**했는지에 따라 상위 스코프가 결정되는 것

## 24.2 함수 객체의 내부 슬롯
렉시컬 스코프를 위해서는 함수 자신이 정의된 환경을 기억해야 한다. <br> 
=> 내부 슬롯[[Environment]]에 자신이 정의된 환경, 즉 상위 스코프의 참조를 저장한다.
## 24.3 클로저와 렉시컬 환경
클로저: 외부 함수보다 중첩 함수가 더 오래 유지되는 경우, 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 클로저라고 부른다. <br>


```
const x =1;

function outer(){
  const x = 10;
  const inner = function(){console.log(x);};
  return inner;
}
//outer 함수를 호출하면 중첩 함수 inner를 반환한다. 
// 그리고 outer 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 팝되어 제거된다.
const innerFunc = outer();
innerFunc();
```
* inner 함수의 내부 슬롯에 outer 함수의 렉시컬 환경을 상위 스코프로서 저장
* outer 함수의 실행이 종료하면 inner 함수를 반환하면서 outer함수의 생명 주기가 종료
<br>=>outer함수의 실행 컨텍스트가 실행 컨텍스트 스택에서 제거된다. 하지만 렉시컬 환경까지 소멸하지는 않는다.
* outer 함수가 반환한 inner함수를 호출하면 렉시컬 환경의 외부 렉시컬 환경에 대한 참조시 inner 함수 객체의 내부 슬롯에 저장되어 있는 참조값이 할당된다.  <br>
=> 중첩함수 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다.
* 클로저에 의해 참조되는 상위 스코프의 변수를 자유 변수라고 부른다.

## 24.4 클로저의 활용

클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다. <br>
=>  상태가 의도치 않게 변경되지 않도록 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용
```
// 카운트 상태 변수
let num = 0;

// 카운트 상태 변경 함수
const increase = function(){
  // 카운트 상태를 1만큼 증가시킨다.
  return ++num;
};

console.log(increase()); // 1
console.log(increase()); // 2
console.log(increase()); // 3

```
위 코드는 오류를 내제한 안좋은 코드이다. <br>
why: 다음 전제 조건을 지켜야 하기 때문
* 카운트 상태(num변수)는 increase 함수가 호출되기 전까지 변경되지 않고 유지되어야 한다. 
* 이를 위해 카운트 상태는 increase 함수만이 변경할 수 있어야 한다. <br>
but 코드상 카운트 상태는 전역 변수를 통해 관리되고 있기 때문에 언제든지 누구나 접근할 수 있고 변경할 수 있다. 

클로저 사용 코드
```
// 카운트 상태 변경 함수
const increase = (function()){
  // 카운트 상태 변수
  let num = 0;
  // 클로저
  return function(){
    // 카운트 상태를 1만큼 증가시킨다. 
    return ++num;
  };
}
```
클로저를 통해 카운트 상태(num변수) 자유변수가 되어 재차 초기화될 일이 없어지며 위의 전제조건을 충족가능

## 24.5 캡슐화와 정보 은닉
캡슐화: 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것<br>
정보 은닉:
* 외부에 공개할 필요가 없는 구현의 일부를 외부에 공개되지 않도록 감추어 적절치 못한 접근으로부터 방지해 정보를 보호한다.
* 객체 간의 상호 의존성, 즉 결합도를 낮추는 효과가 있다. 

