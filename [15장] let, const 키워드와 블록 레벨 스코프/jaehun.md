# 15.1 var 키워드로 선언한 변수의 문제점

- JS의 오래된 버전(until ES5)에서 변수를 선언하는 방법은 var 키워드 하나뿐이었다.
- var 키워드는 다른 언어와는 구별되는 독특한 특징들이 있다.

### 15.1.1 변수 중복 선언 허용

- var 키워드로 선언한 변수는 중복 선언이 가능하다.

```jsx
var x = 1; // 첫 선언
var y = 1; // 첫 선언

var x = 100; // 초기화문이 있으므로 var 키워드가 없는 것처럼 동작!

var y; // 초기화문 없으므로 무시. 오류 발생하지 않음!

console.log(x); // 100 출력
console.log(y); // 1 출
```

- 위 예제 코드에서 확인할 수 있듯 변수 `x`와 `y`가 중복 선언 되었음에도 각각의 상황(초기화문의 여부)에 따라 잘 작동한다.
- 만약 동일한 이름의 변수가 이미 선언되어 있음에도 이를 간과하고 추후 중복 선언과 함께 값까지 할당하게 되면 의도치 않게 기존 변수값이 변경되는 부작용이 발생할 수 있는 문제점이 있다.

### 15.1.2 함수 레벨 스코프

- var 키워드로 선언한 변수는 오직 **함수**의 코드 블록만을 지역 스코프로 인정한다.
- 이외의 경우는 모두 전역 변수가 된다.

```jsx
var x = 1;
if(true) {
	var x = 10;
}
console.log(x); // 10 출력
////////////////////////////////////////////
var i = 10;
for(var i = 0; i < 5; i++) {
	console.log(i); // 0 1 2 3 4
}
console.log(i); // 5 출력
```

- 이처럼 전역 변수를 남발하고, 전역 변수가 중복 선언될 가능성을 높이게 된다.

### 15.1.3 변수 호이스팅

- var 키워드로 변수를 선언하면 변수 호이스팅에 의해 실행 시 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작한다.
- 이와 같은 특징에 의해, var 키워드로 선언한 변수는 변수 선언문 이전에 참조할 수 있다.

```jsx
console.log(num); // undefined 출력
num = 10;
console.log(num); // 10 출력
var num; // 실제로는 가장 먼저 동작
```

- 이와 같은 변수 호이스팅은 개발자의 의도를 벗어나게 될 가능성을 높이며, 가독성을 떨어뜨린다.

# 15.2 let 키워드

- ES6 버전부터는 추가된 `let`과 `const` 키워드를 통해 변수 선언 기능을 지원한다.

### 15.2.1 변수 중복 선언 금지!

- `var` 혹은 `let`으로 이미 선언된 변수를 `let`으로 중복 선언하면 오류를 발생한다.

```jsx
var a = 10;
var a = 15; // 오류 발생하지 않음

let b = 10;
let b = 11; // Syntax Error: Identifier 'bar' has already been declared

```

### 15.2.2 블록 레벨 스코프

- `let` 키워드로 선언한 변수는 모든 코드 블록(함수, `if`문, `for`문, `while`문, `try/catch`문 등)을 지역 스코프로 인정하는 **블록 레벨 스코프**를 따른다.

```jsx
let a = 1; // 전역 변수
{
	let a = 2; // 지역 변수
	let b = 3; // 지역 변수
}

console.log(a); // 1 출력
console.log(b); // ReferenceError: b is not defined
```

- 모든 블록을 지역 스코프로 인정하기에, `{ }` 내부에서 선언된 `a`와 `b` 모두 지역 변수로서 작동한다. 만약 그렇지 않았으면 `a`는 중복 선언으로 처리되어 오류를 발생했을 것 또한 생각해볼 수 있다.

### 15.2.3 변수 호이스팅

- `let` 키워드로 선언한 변수는 변수 호이스팅이 **발생하지 않는 것처럼 보인다**.

```jsx
console.log(a); // ReferenceError: a is not defined

let a;
console.log(a); // undefined

a = 1;
console.log(a); // 1 출력
```

- 위 예제에서, `let a;`를 통해 `a` 변수가 선언되기 전까지 해당 변수를 참조할 수 없는 구간을 **일시적 사각지대**(Temporal Dead Zone : TDZ)라고 부른다.
- 하지만, **실제로 호이스팅은 동작한다.**

```jsx
let a = 3;
{
    console.log(a); // ReferenceError: Cannot access 'a' before initialization
    let a = 4;
}
console.log(a); // 3 출력
```

- 위 코드에서, 호이스팅이 발생하지 않았다면  첫 번째 `console.log(a)`에서 당연히 전역변수 `a`의 값인 `3`을 출력했어야 하지만 실제로는 **Reference Error**를 발생시킨다.
- 이는 엔진이 해당 블록 내에 지역 변수 `a`가 있음을 알았다는 것을 의미하고, 따라서 호이스팅이 발생했음을 알 수 있다.
- 자바스크립트에서, 모든 선언(`var, let, const, function, function*, class` 등)은 호이스팅이 동작되지만, ES6에서 도입된 `let, const, class`를 사용한 선언문은 **호이스팅이 발생하지 않는 것처럼 동작**한다.

### 15.2.4 전역 객체와 **let**

- `var` 키워드로 선언한 전역 변수와 전역 함수, 그리고 암묵적 전역(21.4.3절에 등장 예정)은 전역 객체 `window`의 프로퍼티가 된다.
- 전역 객체의 프로퍼티를 참조할 때 window를 생략할 수 있다.

```jsx
var x = 1;
function func() {} 

console.log(window.x); // 1 출력
console.log(x); // window를 생략한 것뿐! 1 출력

console.log(window.func); // func() {} 출력
console.log(func); // window를 생략한 것뿐! func() {} 출력
```

- 이때, `let` 키워드로 선언한 전역 변수는 전역 객체 `window`의 프로퍼티가 아니다.
- `let` 전역 변수는 “전역 렉시컬 환경의 선언적 환경 레코드” 내에 존재하게 된다고 한다. (23장 [실행 컨텍스트]에서 등장 예정)

# 15.3 const 키워드

- `const` 키워드는 상수를 선언하기 위해 사용한다.
- 하지만 반드시 상수만을 위해 사용하는 것은 아니다. (후반부 설명 예정)
- `const`는 `let`과 거의 동일하므로 `let` 키워드와의 차이점을 중심으로 확인해보도록 한다.

### 15.3.1 선언과 초기화

- **`const` 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.**

```jsx
const a; // SyntaxError: Missing initializer in const declaration

/////////////////////////////////////////////////

const a = 1;
```

- `const` 키워드로 선언한 변수도 `let` 키워드로 선언한 변수와 마찬가지로 블록 레벨 스코프를 가지며, **호이스팅이 발생하지 않는 것처럼** 동작한다.

### 15.3.2 재할당 금지

- `var` 또는 `let` 키워드로 선언한 변수는 재할당이 자유롭지만, `const`로 선언한 변수는 **재할당이 금지된다**.

```jsx
const a = 3;
a = 2; // TypeError: Assignment to constant variable.
```

### 15.3.3 상수

- `const` 키워드로 선언한 변수에 원시 값을 할당한 경우 변수 값을 변경할 수 없다.
- 원시 값은 변경 불가능한 값이므로 재할당 없이 값을 변경할 수 없기 때문이다.

```jsx
let radius = 10;

let area = radius * radius * 3.141592;

console.log(area); //314.1592 출력
```

- 위 코드에서, 3.14가 어떤 의미로 사용됐는지 상수를 통해 정의하면 의미를 쉽게 파악할 수 있을 것이다. (`const PI = 3.141592;`)
- 일반적으로 상수의 이름은 **대문자로 선언해** 상수임을 표현한다. 여러 단어로 이루어진 경우 snake_case로 표현하는 것이 일반적이다.

### 15.3.4 const 키워드와 객체

- `const` 키워드로 선언된 변수에 객체를 할당한 경우 값을 변경할 수 있다.

```jsx
const person = {
	name:'Jaehun';
};

person.name = 'HwanHee';
console.log(person); // {name: "HwanHee"}를 출력
```

- 즉, `const` 키워드는 **재할당을 금지할 뿐** “불변”을 의미하지는 않는다.
- 객체가 변경되더라도 변수에 할당된 참조 값은 변경되지 않는다.

### 15.4 var VS let VS const

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c17c7a0a-829a-4418-bd5b-6416682a77fa/cd9bc932-e2ae-4517-bdc2-1bd4ac039938/Untitled.png)

- 변수 선언에는 기복적으로 `const`를 사용하고, `let`은 재할당이 필요한 경우에만 사용하는 것이 좋다.
- `var`, `let`, `const` 키워드는 다음과 같은 원칙을 통해 사용하는 것을 권장한다.
    - ES6을 사용한다면 `var` 키워드는 사용하지 않는다.
    - 재할당이 필요한 경우에만 `let` 키워드를 사용한다. 이때 변수의 스코프는 최대한 좁게 만든다.
    - 변경이 발생하지 않고 재할당이 필요 없는 원시 값, 그리고 객체에는 `const` 키워드를 사용한다.
- 변수를 선언하는 시점에는 재할당 여부를 바로 알 수 없는 경우가 많고, 객체는 의외로 재할당하는 경우가 드물다. 따라서 변수를 선언할 때는 일단 `const`로 사용하자.
