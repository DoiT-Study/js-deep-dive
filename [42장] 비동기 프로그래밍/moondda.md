함수를 "호출"하면 함수 실행 컨텍스트가 만들어짐. 선언말고 호출.
함수 실행 컨텍스트는 실행 컨텍스트 스택에 푸시/팝 되면서 실행됨

```ts
const foo = () => {};
foo(); //여기서 호출하므로 여기서 함수 실행 컨텍스트가 만들어짐
```
자바스크립트 엔진은 **하나의 실행 컨텍스트**를 갖는다. 2개의 함수를 동시에 실행할 수 없음. => 싱글 스레드 방식
1개만 [실행중]이고 나머지는 [실행 대기 중]으로 들어간다

처리에 시간이 걸리는 태스크의 경우 블로킹(작업중단)이 발생한다 => 동기 처리 방식의 단점 . 실행 순서는 보장됨
실행 중인 태스크가 종료되지 않은 사태여도 다음 태스크를 곧바로 실행 => 비동기 처리 ex. setTimeout, setInterval, HTTP 요청, 이벤트 핸들러

브라우저가 동작하는 모습을 보면, 태스크가 동시에 처리하는거처럼 느껴진다. ex) http 요청을 통해 서버로부터 데이터를 가지고오면서 렌더링을 하는 듯함
이러한 자바스크림트의 동시성을 지원하는 것이 **이벤트 루프**다

자바스크립트 엔진은 크게 **콜스택**,**힙** 으로 나뉜다.
자바스크립트 엔진은 태스크가 요청되면 순차적으로 실행할 뿐이다.
비동기 처리는 브라우저나 Node.js가 거의 담당함.(왜 거의냐면 소스코드 평가 실행은 자바스크립트 엔진이 담당하기 때문)

비동기 처리를 위해 브라우저 환경은 **태스크 큐**와 **이벤트 루프**를 제공한다.

태스크큐 : 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역
이벤트 루프 : 콜 스택에 현재 실행중인 실행 컨텍스트가 있는지, 그리고 태스ㅋ크 큐에 대기 중인 함수가 있는 지 확인함. 또 태스크 큐에서 대기 중인 함수를 콜 스택으로 이동시킴. 

```ts
function foo(){
console.log('foo');

function bar(){
console.log('bar');
}

setTimeout(foo,0);
bar();

```

위의 코드는 실행시키면 bar,foo 중 뭐가 먼저 실행이 될까?
정답은 bar함수이다
출력값
//bar
//foo

[흐름 정리]
setTimeout 함수를 실행하고, 0초 후에 콜백함수인 foo함수를 호출할 것을 예약한다. 이때 foo함수는 태스크 큐에 들어가서 대기를 하게 됨.
bar함수는 동기적이기 때문에 즉시 실행이 된다.
bar함수가 실행을 마치면 태스크 큐에 있던 foo함수가 콜스택으로 이동되어 실행된다. 


+) 비동기 작업은 "동시에 실행된다"기보다는 "다른 작업이 실행되고 있을 때, 기다리는 동안 다른 작업을 처리할 수 있도록 예약된다"고 이해할 수 있다.

자바스크립트 엔진 -> 싱글 스레드 동작
브라우저 -> 멀티 스레드 동작



