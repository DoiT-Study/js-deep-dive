# JS deepdive study 10/12

### 10.4 매서드

메서드란? 프로퍼티 값이 함수일 경우를 칭하는 말이다. 

→ 객체에 묶여있는 함수. 객체의 상태를 나타낸다

(프로퍼티란? 객체 내부의 속성을 칭한다. → 객체는 프로퍼티의 집합이다. 값으로 취급 가능하다면 프로퍼티로 사용 가능)

js의 함수는 일급객체(18.1장에 다룸) → 프로퍼티 값으로 사용가능하다

### 10.5 프로퍼티 접근

1) 마침표 표기법 (dot notation)

마침표 프로퍼티 접근 연산자( . )를 사용한다.

2) 대괄호 표기법 (bracket notation)

대괄호 프로퍼티 접근 연산자( [ ] )를 사용한다.

대괄호 내부의 프로퍼티 키는 ‘ ‘ 로 감싼 문자열이어야 한다. ‘ ‘로 감싸지 않은 이름은 식별자로 인식해 ReferenceError가 발생한다. (숫자로 이루어진 문자열은 예외로 생략 가능하다.)

```jsx
var person = {
	name: ‘Lee’
};
console.log(person[name]); *// ReferenceError: name is not defined*
```

객체에 존재하지 않는 프로퍼티에 접근하면 undefined 반환한다.

프로퍼티 키가 식별자 네이밍 규칙을 준수하지 않으면 꼭 대괄호 표기법 사용해야 한다.

### 10.6 프로퍼티 값 갱신

이미 존재하는 프로퍼티에 값을 할당하면 갱신된다.

```jsx
var person = {
	name: ‘Lee’
};
person.name = 'Kim';*//person 객체에 name 프로퍼티가 존재하므로 name프로퍼티가 갱신된다*
console.log(person);
```

### 10.7 프로퍼티 동적 생성

존재 하지 않는 프로퍼티에 값을 생성하면 프로퍼티가 동적으로 생성되어 추가된다.

```jsx
var person = {
	name: ‘Lee’
};
person.age = 20;

console.log(person);
*// {name: "Lee",  age: 20}*
```

### 10.8 프로퍼티 삭제

delete 연산자 이용한다. 존재하지 않는 프로퍼티 삭제 명령은 무시된다.

```jsx
var person = {
	name : 'Lee'
};
person.age = 20;
delete person.age;
conslole.log(person);
// {name: "Lee"}
```

### 10.9 ES6에서 추가된 객체 리터럴의 확장기능

10.9.1 프로퍼티 축약 표현

프로퍼티 값으로 변수 사용할때 변수와 프로퍼티가 동일한 이름 → 프로퍼티 키 생략가능. 변수 이름으로 자동 생성된다.

```jsx
let x = 1, y = 2;

const obj = {x,y}; *//프로퍼티 축약 표현*

console.log(obj); *// {x: 1, y: 2}*
```

10.9.2 계산된 프로퍼티 이름

“문자열” 또는 “문자열로 타입 변환될 수 있는 값”으로 평가되는 표현식을 대괄호로 묶어서 사용하면 프로퍼티 키를 동적으로 생성할 수 있다.

이를 “계산된 프로퍼티 이름”이라 한다.

ES5에서는 객체 리터럴 외부에서 대괄호( [ ] )표기법을 사용해야하고 ES6에서는 객체 리터럴 내부에서도 사용 가능하다.

```jsx
//ES5의 경우
var prefix = 'prop';
var i = 0;

var obj = {};

obj[prefix + '-' + i++];  //"계산된 프로퍼티 이름"으로 프로퍼티 키 동적 생성
obj[prefix + '-' + i++];
obj[prefix + '-' + i++];
console.log(obj);
// {prop-1: 1,prop-2: 2,prop-3: 3}
```

```jsx
//ES6
const prefix = 'prop';
let i = 0;

const obj = {
	['${prefix}-${++i}']: i,
	['${prefix}-${++i}']: i,
	['${prefix}-${++i}']: i
};
console.log(obj);
// {prop-1: 1,prop-2: 2,prop-3: 3}
```

10.9.3 메서드 축약 표현

ES5에서는 프로퍼티 값으로 함수를 할당해서 메서드를 정의한다.

ES6에서는 function키워드를 생략한 축약표현으로 매서드를 정의한다.

```jsx
ES5
var obj = {
	name: 'Lee',
	sayHi: function(){   //  -> sayHi(){ 로 ES6에서 사용한다
		console.log('Hi!' = this.name);
	}
};
obj.sayhi();
// Hi Lee
```

### 11.1 원시 값

11.1.1 변경 불가능한 값

원시 타입의 값(primitive type)은 읽기 전용 값으로 변경 불가능하며, 변수에 재할당해서 값을 변경하는 것”처럼” 보이는 것과 구분해야한다. 데이터의 신뢰도 높다.

상수는 재할당이 금지된 “변수”이다. 상수도 값을 저장하기 위한 메모리 공간이 필요하다.

상수 ≠ 변경 불가능한 값

원시값a를 할당한 변수X에 새로운 원시값b를 할당하는 과정 : 새로운 메모리 공간X에 원시값b를 집어넣고 변수의 참조하는 주소를 X로 바꿈 → 결국 a,b모두 메모리상에는 존재한다.

(139pg 그림 11-1 참고)

원시 값을 할당한 변수는 재할당 말고는 값을 변경 불가능하다. = 불변성

11.1.2 문자열과 불변성

숫자는 1이나 9999나 같은 8바이트지만 문자열의 경우 1개의 문자당 2바이트가 필요하다.

자바에서는 문자열을 String 객체로 처리하며 C와 달리 문자열 타입이 있어서 편리하다.

문자열은 유사 배열 객체이고 “이터러블”이므로 배열과 유사하게 각 문자에 접근 가능하지만, 원시값이므로 각 배열의 값을 따로 변경할 수 없다.

```jsx
var str = ‘string’;

str[0] = ‘S’;
console.log(str);
//string
```

11.1.3 값에 의한 전달 = 참조에 의한 전달 = 공유에 의한 전달

변수a에 10이라는 숫자 값을 할당하고 변수copy에 변수a를 할당하면,

방법1 : 변수a의 10이라는 원시값이 복사되어 변수copy에 할당된다.

방법2 : copy도 a의 10을 참조하다가, 재할당 되는 시점에 다른 메모리에 분리되어 할당된다. (파이썬도 이 방식)

144pg 그림 11-4, 11-5 참고

= 값에 의한 전달

변수a와 변수copy의 10이라는 값은 다른 메모리에 저장된 별개의 값이다. 따라서 변수a의 10을 이후 변경해도 변수copy의 값에는 영향이 없다.

변수와 같은 식별자는 값이 아니라 메모리 주소를 기억한다. 즉, 식별자는 메모리 주소에 붙인 이름이다.